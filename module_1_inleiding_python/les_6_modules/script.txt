Intro
=====

Welkom bij les 6 uit de cursus "Inleiding programmeren in Python",
onderdeel van de WizTech lessenserie.
Deze les gaat over modules en packages.
Mijn naam is Jacques de Hooge.

In de vorige les stonden heb je kennis gemaakt met klassen. Klassen waren een manier om je programma in overzichtelijke onderdelen op te splitsen. Alle methods en fields die niet met een underscore beginnen, horen daarbij bij het public interface van een klasse, samen met de constructor. Het public interface, ook wel API of Application Programmer Interface genoemd, is dat deel van de klasse wat bedoeld is voor gebruik door andere onderdelen van je programma. We zeggen ook wel dat het public interface een outside view, buitenaanzicht, geeft van objecten van die klasse. Als methoden en velden daarentegen met een enkele underscore beginnen, horen ze bij de inside view, bij de veranderelijke interne details van die klasse.

Het is zaak de outside views van objecten zo beperkt klein en simpel mogelijk te houden: thin interfaces. Met andere woorden: geef een klasse niet teveel publieke methoden en velden, want dan worden objecten te afhankelijk van elkaar en bij de geringste verandering aan een van de vele public methods of fields, doet je programma het niet meer. Om dezelfde reden is het belangrijk parameterlijsten van public methods niet nodeloos lang te maken. Want als daar ook maar iets aan verandert, moet alle code die die functies aanroept, aangepast worden. Dit geldt overigens niet als parameterlijsten alleen maar worden uitgebreid, omdat de nieuwe parameters default values kunnen krijgen, dan hoef je ze niet bij de aanroep mee te geven in bestaande code. Maar in het algemeen hebben de methoden van klassen veel minder parameters dan functies die niet bij een klasse horen. Dat komt omdat veel van wat bij een losse functie voortdurend opnieuw moet worden doorgegeven, nu door de constructor wordt opgeslagen in de velden van de objecten. Zo kunnen de methods het gebruiken zonder dat ze het via een parameter ontvangen.

Omdat klassen relatief onafhankelijk van elkaar kunnen zijn, is het vaak mogelijk ze zo te ontwerpen dat ze in meerdere programma's kunnen worden gebruikt: code reuse, code hergebruik. Het zou daarom handig zijn als er een manier bestond om een verzameling samenhangende, herbruikbare klassen in een apart bestand op te slaan. Dan kun je dat in uiteenlopende programma's gebruiken, of, zoals we zeggen, importeren. We hebben het dan over "modules". Een module is een verzameling herbruikbare klassen, functies, en, heel soms, objecten.

Een voorbeeld van dat laatste is pi, een object van de klasse float, dat zoals je in les 3 zag, door de mathematics module wordt geexporteerd.
In deze cursus focussen we op object oriented design en wat er wordt geexporteerd door een module, en ergens anders weer geimporteerd, zijn meestal klassen. Dat is lekker algemeen, want dan kun je in een andere module daar net zoveel objecten van maken (instantieren zeggen we met een vakterm) als je nodig hebt.

Ook modules kunnen weer in groepjes worden samengenomen, bijvoorbeeld samenhangende modules die nodig zijn voor technisch-wetenschappelijk rekenwerk. Zo's verzameling samenhangende modules wordt een package genoemd. Het bekende package NumPy, Numerical Python, is hier een voorbeeld van. Het bestaat uit een flink aantal modules, waarbij elke module een deelgebied van de numeriek wiskunde bestrijkt. Zo zijn in NumPy modules om stelsels vergelijkingen op te lossen, maar bijvoorbeeld ook om het frequentiespectrum van signalen te berekenen. Misschien stuiter je van de wis- en natuurkundige termen die ik hier gebruik, maar maak je geen zorgen, de voorbeelden in deze Python-cursus gaat niet of nauwelijks over wiskunde. Je hoeft dus niet te weten wat een frequentiespectrum of een stelsel vergelijkingen is.

Waar het om gaat is dat een verzameling samenhangende klassen kan worden verpakt in een module, een apart bestand. Een verzameling samenhangende modules kan op z'n beurt weer worden verpakt in een package, dat bestaat uit een aantal folders en subfolders met daarin de modulebestanden van dat package. In deze cursus focussen we op modules, met in het achterhoofd het feit dat die desgewenst weer tot packages kunnen worden samengesteld.

Heel in het algemeen is een module een verzameling broncode die aan twee eisen voldoet:

Ten eerste: Er is sprake van interne samenhang binnen de module: cohesie. Dit houdt in dat je niet van alles en nog wat in een module stopt, maar dat een module in principe EEN duidelijk omschreven doel dient, bijvoorbeeld figuren tekenen, of webservers bouwen, of robots aansturen.

Ten tweede: Er is sprake van het vermijden van onnodige koppeling tussen modules onderling. Immers is het niet te bedoeling dat je, als je een robotje wilt besturen, ook afhankelijk wordt van code om een webserver te bouwen. Dit vermijden van nodeloze afhankelijkheden is in de techniek over het algemeen een groot goed. Domotica, het automatiseren van je huis, is een leuke hobby. Maar dat je, als je Internet provider weer eens plat gaat, je huis niet meer in kunt, is minder leuk. Het is een typisch gevolg van nodeloze koppeling. Zoals eerder genoemd, KISS, keep it simple, stupid. Als alles van alles afhangt, hoeft er maar EEN DING mis te gaan, en ALLES gaat mis. We spreken wel van een "Single Point of Failure".

Coupling en cohesion zijn de centrale begrippen bij het zogenaamde "modulair ontwerpen": Het opbouwen van software uit zelfstandige, robuste, herbruikbare onderdelen. Overigens is de betekenis van modulair ontwerpen niet beperkt tot het maken van software. Ook bij bijvoorbeeld het ontwerpen van huizen, auto's, stroomvoorziening en communicatie-netwerken is modulair ontwerpen belangrijk. Als het goed wordt gedaan, vermindert het niet alleen de kosten maar ook de kwetsbaarheid voor een Single Point of Failure. Band lek: wielmodule verwisselen. Velg en band zijn tamelijk innig verbonden: cohesion binnen de wielmodule. Maar er is geen onnodige coupling met de rest van de auto, het thin interface bestaat maar uit vier of vijf bouten.

Een goed modulair ontwerp vermindert trouwens niet alleen kosten en kwetsbaarheid, maar ook de afhankelijkheid van bepaalde bedrijven. Het wordt mogelijk delen van een uitgebreide softwaretoepassing naar keuze bij andere fabrikanten te betrekken "Second Sourcing".

